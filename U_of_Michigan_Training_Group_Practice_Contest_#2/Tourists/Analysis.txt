Intution:

In a tree, the shortest distance between any two nodes (u,v) with lowest common ancestor c is the distance from u to c + distance from v to c. This can also be written as: depth(u) - 2*depth(c) + depth(v). See proof below.
  distance(u to v) 
  = distance(c to u) + distance(c to v) 
  = distance(root to u) - distance(root to c) + distance(root to v) - distance(root to c)
  = depth(u) - depth(c) + depth(v) - depth(c) [by definition of depth]
  = depth(u) - 2*depth(c) + depth(v)

Strategy:
Choose an artitrary node to be the root.
Calculate depth of every node.

For every start node, we calculate the distance to every node it is a factor of (greater than itself). These form a pair (u, v). To do this, we must find the distance from each to the LCA of both. 
  A naive implementation is: advance the deeper node upward (parent-wise) until both u and v are on the same level. Then advance both u and v at the same time until they reach the same node. That's the LCA.
  This makes our solution O(N^2) if the tree is a stick and the root is 1.

  What if we could make this logarithmic by advancing up the deeper node faster than one-by-one? We can advance it by powers of 2. If we precompute each node's 2^j'th level (0 <= j <= D = ceiling(log2(N))), we can make any advancement of length k up this ancestral tree O(logK). More explicity, we build a matrix par where par[i][j] is the 2^j'th parent of node i.

Procedure:
1. DFS with root = 0. Memoize the depths of every node and each node's immeidate parent.    
2.  For each 1 <= u <= N:
      For each u + u <= v <= N:
        c = lca(u, v)
        distance(u to v) = depth(u) - 2*depth(c) + depth(v)


1. O(N)
2. For loops are O(NlogN); each lca(u, v) is O(logN); depths are memoized so O(1)