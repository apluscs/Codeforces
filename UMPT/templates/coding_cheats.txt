const int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
const int dir[8][2] = {{0, 1}, {0, -1}, {1, 0},  {-1, 0},
                       {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};

// out function
bool out(int i, int j) { return i <= -1 || i >= n || j <= -1 || j >= m; }


// floodfill
void dfs(int i, int j) {
  reps[i * 50 + j] = R;
  for (auto d : dir) {
    int ni = i + d[0], nj = j + d[1], nid = ni * 50 + nj;
    if (!out(ni, nj) && grid[ni][nj] == 1 && reps.count(nid) == 0) {
      dfs(ni, nj);
    } else if (!out(ni, nj) && grid[ni][nj] == 0)
      in_danger.insert(nid);
  }
}

// vector of ints to a string
stringstream ss;
copy(v.begin(), v.end(), ostream_iterator<int>(ss, " "));
string s = ss.str();

// sort array in reverse order
sort(arr, arr + n, greater<int>());

// prefix sum
int n = w.size();
prefix.resize(n + 1);
for (int i = 1; i != n + 1; ++i) {
  prefix[i] = w[i - 1] + prefix[i - 1];
}
// cout<<endl;

// split a string by spaces
istringstream ss(str);

// Traverse through all words
do {
  // Read a word
  string word;
  ss >> word;

  // Print the read word
  cout << word << endl;

  // While there is more to read
} while (ss);

// printing shit out
cout << start << ", " << end << ", " << k << endl;

long getNextPalindrome(long a) {
  string s = to_string(a);
  int n = s.size(), i = (n + 1) / 2;
  while (--i >= 0)
    if (s[i] == '9')
      s[i] = s[n - i - 1] = '0';
    else
      break;
  if (i == -1) return a + 2;
  s[i]++;
  if (i != (n - i - 1)) s[n - i - 1]++;
  return stol(s);
}

int hammingDistance(int x) {  // count #ones
  int count = 0;
  for (int i = 0; i < 32; i++)
    if (x & (1 << i)) count++;
  return count;
}

// lcm
long lcm(long a, long b) { return (a * b) / __gcd(a, b); }

// random double [lower,upper]
double fRand(double lower, double upper) {
  upper = std::nextafter(upper, std::numeric_limits<double>::max());
  std::uniform_real_distribution<double> unif(lower, upper);
  std::default_random_engine re;
  double a_random_double = unif(re);
  return a_random_double;
}

// random int
srand(time(NULL));
int r = rand() % range + 0;  // range is [inclusve,exclusive)

// hashing
struct pair_hash {
  template <class T1, class T2>
  size_t operator()(pair<T1, T2> const& pair) const {
    size_t h1 = std::hash<T1>()(pair.first);
    size_t h2 = std::hash<T2>()(pair.second);

    return h1 ^ h2;
  }
};
unordered_set<pair<int, int>, pair_hash> vis;

// custom sort a vector
struct compar {
  bool operator()(const vector<int>& a, const vector<int>& b) const {
    return a[0] < b[0];
  }
};

// struct with < operator
struct Cell {
  int i, j, h;
  Cell(int i, int j, int h) : i(i), j(j), h(h) {}
  bool operator<(const Cell& other) const { return h < other.h; }
};

// frq calculation
unordered_map<int, int> frq;
for (int num : nums) frq[num]++;

// to find the key <= k in a map, do
auto it == m.upper_bound(k);
return m.begin() ? "" : prev(it)->second;

// BFS template
const char ops[4] = {'A', 'C', 'G', 'T'};
unordered_set<string> have(bank.begin(), bank.end());
int res = 0;
queue<string> que;
unordered_set<string> vis;
que.push(start);
while (!que.empty()) {
  int m = que.size();
  for (int i = 0; i != m; ++i) {
    string curr = que.front();
    que.pop();
    if (curr == end) return res;
    if (vis.count(curr)) continue;
    vis.insert(curr);
    // cout<<curr<<endl;
    for (int j = 0; j != 8; ++j) {
      int temp = curr[j];
      for (char op : ops) {
        curr[j] = op;
        if (vis.count(curr) || have.count(curr) == 0) continue;
        que.push(curr);
      }
      curr[j] = temp;
    }
  }
  res++;
}

// grid BFS
int bfs(vector<int>& start, vector<int>& end, vector<vector<int>>& grid) {
  if (start == end) return 0;
  int res = 1;
  queue<pair<int, int>> que;  // use pairs instead of vectors
  vector<vector<bool>> vis(n, vector<bool>(m));
  que.push(make_pair(start[0], start[1]));
  vis[start[0]][start[1]] = true;
  while (!que.empty()) {
    int s = que.size();
    for (int i = 0; i != s; ++i) {
      auto curr = que.front();
      que.pop();
      // cout<<curr<<endl;
      for (auto d : dir) {
        int ni = d[0] + curr.first, nj = d[1] + curr.second;
        if (ni == -1 || ni == n || nj == -1 || nj == m || vis[ni][nj] ||
            grid[ni][nj] == 0)
          continue;
        vis[ni][nj] = true;                            // mark as visited here
        if (ni == end[0] && nj == end[1]) return res;  // check end here
        que.push({ni, nj});
      }
    }
    res++;
  }
  return -1;
}

// interval dp
vector<vector<int>> dp(n, vector<int>(n, 1));
for (int len = 1; len != n; ++len) {
  for (int i = 0, j = i + len; j != n; ++i, ++j) {
  }
}

// factorial
long factorial(int n) {
  return n ? factorial(n - 1) * n % (long)(1e9 + 7) : 1;

  bool out(int i, int j) { return i < 0 || i > 7 || j < 0 || j > 7; }
  bool out(int i, int j) { return i < 0 || i >= n || j < 0 || j >= m; }
  
  int mygcd(int x, int y) {
    while ((x %= y) && (y %= x))
      ;
    return x + y;
  }

  ll power(ll x, ll y) {  // x to y'th power, all modded
    ll t = 1;
    while (y != 0) {
      if (y % 2 == 1) t = t * x % mod;
      x = x * x % mod;
      y /= 2;
    }
    return t;
  }

  ll fact(int x) {  // factorial of x, all modded
    ll res = 1;
    while (x) res = (res * x--) % mod;
    return res;
  }

  bool deci_less(string a, string b) {  // if a < b
    if (a.length() != b.length()) return a.length() < b.length();
    for (int i = 0; i != a.length(); ++i) {
      if (a[i] != b[i]) return a[i] < b[i];
    }
    return false;
  }

  vector<int> get_failure(string & str) {
    int m = str.length();
    vector<int> res(m);
    for (int i = 1, j = 0; i != m; ++i) {
      while (j != 0 && str[j] != str[i]) j = res[j - 1];
      if (str[i] == str[j]) res[i] = ++j;
    }
    return res;
  }
  
  /*
  Needle:
    abaabab
    0011232   // failure table
          ^___j
  Haystack:
      abaabaX**** // mismatch occurred at i
            ^________i
  Needle will readjust to: j = 3
      abaabab
      0011232   // failure table
         ^___j
  */     
  
  void print(vector<int>& nums){
    for(auto num:nums)cout<<num<<" ";cout<<endl;
  }
  
  void print(vector<vector<int>>& nums){
    for(auto& row:nums)print(row);
  }
  
  
